package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"regexp"
	"strings"
)

var apiKey string

type CVSSResponse struct {
    Result struct {
        CVEItems []struct {
            Impact struct {
                BaseMetricV2 struct {
                    CvssV2 struct {
                        BaseScore float64 `json:"baseScore"`
                    } `json:"cvssV2"`
                } `json:"baseMetricV2,omitempty"`
            } `json:"impact"`
        } `json:"CVE_Items"`
    } `json:"result"`
}

func getCvssScore(cveId string) (float64, error) {
    url := fmt.Sprintf("https://services.nvd.nist.gov/rest/json/cves/2.0/%s", cveId)
    req, err := http.NewRequest("GET", url, nil)
    if err != nil {
        log.Printf("Error creating request for CVE %s: %v\n", cveId, err)
        return 0, err
    }
	req.Header.Add("apiKey", apiKey)
	
    resp, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Printf("Error fetching CVSS score for %s: %v\n", cveId, err)
		return 0, err
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
    if err != nil {
        log.Printf("Error reading response body for %s: %v\n", cveId, err)
        return 0, err
    }
    bodyString := string(bodyBytes)
    log.Printf("Raw response for %s: %s\n", cveId, bodyString)

    var response CVSSResponse
    err = json.Unmarshal(bodyBytes, &response)
    if err != nil {
        log.Printf("Error decoding JSON response for %s: %v\n", cveId, err)
        return 0, err
    }

    if len(response.Result.CVEItems) > 0 && response.Result.CVEItems[0].Impact.BaseMetricV2.CvssV2.BaseScore != 0 {
        return response.Result.CVEItems[0].Impact.BaseMetricV2.CvssV2.BaseScore, nil
    }

    log.Printf("No CVSS score found for %s. Response: %+v\n", cveId, response)
    return 0, fmt.Errorf("No CVSS score found for %s", cveId)
}

func main() {
	apiKey = os.Getenv("NIST_API_KEY")
	if apiKey == "" {
		log.Fatal("API key is not set. Please set the NIST_API_KEY environment variable.")
	}

    if len(os.Args) != 2 {
        fmt.Println("Usage: go run test.go [image name]")
        return
    }
    imageName := os.Args[1]

    scoutCmd := exec.Command("docker", "scout", "cves", imageName)
    scoutOutput, err := scoutCmd.CombinedOutput()
    if err != nil {
        log.Fatalf("Failed to scan image with Docker Scout: %v\nOutput:\n%s", err, scoutOutput)
    }

    grypeCmd := exec.Command("grype", imageName)
    grypeOutput, err := grypeCmd.CombinedOutput()
    if err != nil {
        log.Fatalf("Failed to scan image with Grype: %v\nOutput:\n%s", err, grypeOutput)
    }

    combinedReport := CombineReports(string(scoutOutput), string(grypeOutput))
    fmt.Println("Combined Vulnerability Report:")
    fmt.Println(combinedReport)
}

func CombineReports(scoutReport, grypeReport string) string {
    combinedReport := scoutReport + "\n" + grypeReport

    cveMap := make(map[string]float64)
    cveRegex := regexp.MustCompile(`CVE-\d{4}-\d{4,7}`)

    scanner := bufio.NewScanner(strings.NewReader(combinedReport))
    for scanner.Scan() {
        line := scanner.Text()
        if strings.Contains(line, "CVE") {
            matches := cveRegex.FindAllString(line, -1)
            for _, cve := range matches {
                cveMap[cve] = 0.0
            }
        }
    }

    var totalScore float64
    count := 0
    for cve := range cveMap {
        score, err := getCvssScore(cve)
        if err == nil {
            cveMap[cve] = score
            totalScore += score
        }
		count++
    }

    var avgScore float64
    if count > 0 {
        avgScore = totalScore / float64(count)
    }

    finalReport := fmt.Sprintf("Total CVEs: %d\nAverage CVSS Score: %.2f\n", count, avgScore)
    for cve, score := range cveMap {
        finalReport += fmt.Sprintf("%s: %.2f\n", cve, score)
    }

    return finalReport
}